
The Virginian Database
======================

Peter Bakkum <pbb7c@virginia.edu>
Written Summer 2010 at NEC Laboratories America in Princeton, New Jersey

Introduction
------------

This is an experimental heterogeneous SQL database written to compare data
processing on the CPU and NVIDIA GPUs. It was written by Peter Bakkum
during the summer of 2010 at NEC Laboratories America in Princeton, New Jersey
with several subsequent expansions. It shares no code with any other database
system. A thanks goes to the Systems Architecture group at NEC, Srimat
Chakradhar in particular, and the LAVA Lab group at UVa, Prof Kevin Skadron in
particular.

The purpose of this database is to test and demonstrate several novel ideas
relating to RDBMS-like computation on the GPU. Thus, all queries can be executed
on the CPU with a single thread, the CPU with multiple threads, or the GPU.
Chief among the ideas demonstrated here is the data structure used both for data
storage and execution across both platforms, the Tablet, around which the entire
database has been constructed.

This is a "SQL Database" in that it has a SQL interface and is capable of
performing several types of queries on non-volatile data, but is far from
supporting the full SQL standard. It is not suitable for production, but has
been written to be small and make it easy to experiment and compare execution on
the CPU and GPU.

This code was developed on Linux 2.6 machines and tested with NVIDIA Tesla
C1060, Geforce GTX 570, and Tesla C2050 cards on CUDA 3.0 and above. Compiling
will at the very least probably involve tweaking the project makefile, and might
involve changing some code. The code involves system calls to unix libraries, so
compiling on anything other than Linux may be harder, and compiling on Windows
may require some major changes, though I've never tried it. As stated, this is
an experimental project and it will be difficult to use if you are unfamiliar
with C and CUDA.

Documentation generated by Doxygen is provided in the doc/ folder. It can be
viewed by opening html/index.html with a web browser or by running make in the
latex/ directory to generate a pdf of the documentation.

License
-------

This software is provided "as is" and any expressed or implied warranties,
including, but not limited to, the implied warranties of merchantibility and
fitness for a particular purpose are disclaimed. In no event shall the
regents or contributors be liable for any direct, indirect, incidental,
special, exemplary, or consequential damages (including, but not limited to,
procurement of substitute goods or services; loss of use, data, or profits;
or business interruption) however caused and on any theory of liability,
whether in contract, strict liability, or tort (including negligence or
otherwise) arising in any way out of the use of this software, even if
advised of the possibility of such damage.

Compilation
-----------

Initial compilation should be done by running make in the project root
directory. This will download and compile the GNU Scientific Library, which
is used for generating random numbers for test databases. It will then create
a 1,000,000 row test database and call make in the src/ directory, which
will make all of the project source files and run a test to compare the
running times of queries for single and multicore CPU execution and GPU
execution. These tests can be run again just by executing make in the src/
directory.

There are 3 modes of compilation: debug, gccrelease, and iccrelease. The
gccrelease settings enable optimization, and the iccrelease settings compile
with optimization using icc. Timing results should only be reported from
release settings. The compilation mode is set in the Makefile in the src/
directory.

Before compiling you should look in src/Makefile and tweak the settings for your
machine.

The following programs are required for compilation:

- gcc
  This is always accessed through nvcc and if compiling in the debug or
  gccrelease modes. Last tested with gcc v4.5.2, and v4.4 with nvcc, which
  is not compatible with 4.5.

- g++
  Used for running and compiling test code written in C++. Last tested with g++
  v4.5.2.

- nvcc
  CUDA compiler, used for GPU related code. Last tested with nvcc v4.0.

- flex
  Used for SQL code compiler. Last tested with flex v2.5.

- bison
  Used for SQL code compiler. Last tested with bison v2.4.

- awk
  There is an awk script that scrapes a header file to automatically generate a
  C file used for debugging. Last tested with mawk v1.3.3.

- make
  This project lives in a make world. Last tested with GNU Make v3.81.

- icc
  This is optional for producing an optimized release with the iccrelease
  setting. Interesting because Intel optimizes slightly different than gcc. Last
  tested with v11.1. I have not tried this recently and it may be broken. Note
  that even if using icc, nvcc still uses gcc for compilation under the hood.

Using the Virginian API
-----------------------

This project's interface is well documented but I haven't taken the step of
dividing the user-facing and internal functionality, so the documentation covers
both. Using the code externally should be fairly straightforward. The
compilation and testing process outputs an archive file to the lib/ directory
that can be compiled with another C/C++ project. The files you need are
lib/virginian.a and lib/virginian.h. The example/ directory contains a very
simple project useful for getting started using this code.

Compile-time Options
--------------------

There are several macros that change the program at compile time. They are
added by editing the CUSTOM_FLAGS variable of the Makefile in the src/
folder. The format should be -D MACRO_NAME.

- VIRG_DEBUG
  Enables debugging code, such as printing out the higher-level opcodes as
  they execute and initializing memory areas to 0xDEADBEEF.

- VIRG_DEBUG_SLOTS
  Enables tablet slot information printing to stdout. This prints out a
  listing of the tablet ids and locks whenever a lock is acquired or
  released.

- VIRG_NOPINNED
  Do not declare the main-memory tablet slots as pinned. This switches the
  allocation to a malloc() rather than a cudaMallocHost(). This means that
  GPU execution cannot use streaming or mapped memory.

- VIRG_NOTWOSTEP
  Do not buffer results temporarily in GPU global memory before writing them
  to main memory. This two-step copy operation makes mapped memory on the
  C1060 faster by an order of magnitude but should be disabled for ION boards
  because there is no distinction between GPU memory and main memory.


Opcodes
-------

These opcodes are the steps into which a query is broken down. Each opcode
has four arguments, though few opcodes use all four. The first three are
integer values, while the fourth can be any type.

In general the first two opcodes are used to refer to virtual machine
registers and the third is used to refer to a program counter value, such as
the end of the parallel section. These are just conventions, however, and not
all opcodes are organized in this way.

These opcodes are loosely based on the SQLite opcodes but have a number of
subtle semantic differences. The SQLite opcodes can be seen at
http://sqlite.org/opcode.html. The changes have been made both to better
support heterogeneous execution and to make things a little simpler. The
biggest change is that even though the virtual machine operating on each row
can diverge and have an independent program counter, that program counter can
never decrease. In other words, execution over the data-parallel segment
proceeds as a waterfall, so opcodes can only jump ahead.

Higher-Level Opcodes
--------------------

These opcodes control setting up query execution and launching the
data-parallel segment. These opcodes do not handle row data directly and are
implemented in vm/execute.c. They are listed in alphabetical order.

- Finish [], [], [], []
  This opcode marks the end of the data-parallel segment of query execution.
  Its purpose is to provide a jump location for the higher-level virtual
  machine and to clean up the remaining tablet locks of the data-parallel
  segment.

- Parallel [], [], [end of parallel section], []
  Begins the data-parallel segment of query execution. Depending on the
  configuration settings, this either launches a single-core, multi-core, or
  GPU virtual machine that treats every row as independent in its processing.
  The third argument refers to the opcode marking the end of the parallel
  segment, which should always be Finish.

- ResultColumn [column type], [], [], [column name]
  Prepares the result tablet to receive a certain column of data. The type is
  one of the integer enumerations of data types, such as VIRG_INT, and the
  name is a character pointer to a location in memory of a c string
  containing the result column names. Note that only the semantics to call
  this opcode once are currently implemented.

- Table [table id], [], [], []
  Opens a handle on a table for execution. Required when beginning execution.


Lower-Level Opcodes
-------------------

These opcodes are used to work directly with the data of a table, and can be
independently executed for each row. They are specifically designed to be
platform independent, meaning they are used for both CPU and GPU execution.
Intermediate data during this lower-level step is stored in the virtual
machine registers, which are unions that allow the virtual machine to
temporarily store any variable type. They should not be confused with the
notion of the CUDA register space, and in fact are stored in local memory on
the GPU.

The four arguments are referred to as p1, p2, p3, and p4. Register locations
are referred to as a reg[] array. Thus, reg[p1] refers to the p1-th virtual
machine register.

One of the virtual machine elements associated with each row is the concept
of validity. The SELECT operation is just a filter, so we determine which
rows are valid and invalid, and the ResultRow opcode only outputs those rows
which are valid. This is different from the SQLite semantics, where only
valid rows execute this opcode, and this change was intended to better
support coordination among threads on the GPU and within the SIMD block on
the GPU.

- Add [destination register], [source register 1], [source register 2], []
  Executes the operation reg[p1] = reg[p2] + reg[p3].

- And [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] && reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Cast [target type], [register], [], []
  Casts the value in register p2 to the type denoted by p1, such as VIRG_INT.

- Column [destination register], [source column], [], []
  Loads the value from from the p2-th fixed column of the current table and
  places it in the p1-th register.

- Converge [], [], [], []
  Marks the end of the data-parallel query execution segment. This opcode
  causes the lower-level virtual machine to exit and return control to the
  higher-level virtual machinemachine.

- Div [destination register], [source register 1], [source register 2], []
  Executes the operation reg[p1] = reg[p2] / reg[p3].

- Eq [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] == reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Float [destination register], [], [], [constant]
  Sets the value of reg[p1] to the float value of p4.

- Ge [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] >= reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Gt [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] > reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Integer [destination register], [constant], [], []
  Sets the value of reg[p1] to p2, which is an integer value.

- Invalid [], [], [], []
  Invalidates all rows that have this opcode executed, so the only rows that
  are output by ResultRow are those that jump over this opcode.

- Le [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] <= reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Lt [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] < reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Mul [destination register], [source register 1], [source register 2], []
  Executes the operation reg[p1] = reg[p2] * reg[p3].

- Neq [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] != reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Not [test register], [], [jump location], [validity]
  If reg[p1] evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Or [comparison register 1], [comparison register 2], [jump location],
  [validity]
  If (reg[p1] || reg[p2]) evaluates to true, then the program counter
  associated with this row jumps to p3 and the rows validity is set to the
  integer value of p4.

- Result [start register], [result columns], [], []
  If the current row is still valid then output the registers from reg[p1] to
  reg[p1 + p2] as a row of fixed-size results. The CPU virtual machine
  attempts to efficiently group the copies of a column in adjacent rows,
  while the GPU coalesces these writes after an atomic scatter operation
  conducted in two-steps in shared and global memory.

- Rowid [destination register], [], [], []
  Loads the value of the current row's primary key and places it in reg[p1]

- Sub [destination register], [source register 1], [source register 2], []
  Executes the operation reg[p1] = reg[p2] - reg[p3].


